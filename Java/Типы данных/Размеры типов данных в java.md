### Примитивные типы данных
| Тип     | Размер,<br>байт | Размер,<br>бит | Диапазон значений   | Значение по умолчанию  | Описание                           |
| ------- | --------------- | -------------- | ------------------- | ---------------------- | ---------------------------------- |
| `byte`   | 1               | 8              | -128 .. 127         | `0`                    | Самое маленькое целое — один байт  |
| `short`  | 2               | 16             | -32,768 .. 32,767   | `0`                    | Короткое целое, два байта          |
| `int`    | 4               | 32             | -2x10^9 .. 2x10^9   | `0`                    | Целое число, 4 байта               |
| `long`   | 8               | 64             | -9x10^18 .. 9x10^18 | `0L`                   | Длинное целое, 8 байт              |
| `float`  | 4               | 32             | -1038 .. 1038       | `0.0f`                  | Дробное, 4 байта                   |
| `double` | 8               | 64             | -10308 .. 10308     | `0.0d`                  | Дробное, двойной длины, 8 байт     |
| `boolean`| 1               | 8              | `true`, `false`       | `false`                 | Логический тип (`true` или `false`) |
| `char`   | 2               | 16             | 0 .. 65,535         | `'\u0000'`              | Символы, 2 байта, все больше 0     |

Переменная byte в Java на самом деле занимает 4 байта в памяти. Однако это неверно для массивов. Хранение массива byte из 20 байт на самом деле составляет всего 20 байт (+ over head) в памяти.

Это потому, что язык байт-кода Java знает только два типа целых чисел: `int` и `long`. Эти типы занимают 4 и 8 байт в памяти.

Однако Java знает массивы со всеми форматами целых чисел.
Т.к. массив является объектом в java, ему необходима память на хранение самого объекта (over head) + память для каждого элемента массива.

### Массивы
> Массив - это объект в java

- индексы массивов в Java используют 32-битные целые числа (int).

К размеру обычного объекта в массиве добавляется over head 4 байта (для хранения размера массива).
Но скорее всего over head будет еще + 4 байта в виде мертвого пространства из-за ограничений по выравниванию до 8 байт (но в некоторых случаях это место может занять какая-л inf-я из массива и мертвого пространства не будет).

#### Приблезительный расчет размера массива
> Размер занимаемой памяти объектом зависит от конкретной реализации JVM

- `Object header` - занимает место = двум машинным словам
- `length-field` - поле, хранящее размер массива(int) = 4 байта
- `sizeof(..) * length` - В памяти резервируется место сразу под всю длину массива.
  Где:
  - `sizeof(..)` - размер 1 объекта, хранимого в массиве;
  - `length` - длина массива.

##### 32 bit системы
1) Массив примитивных типов (`boolean`, `byte`, `char`, `short`, `int`):
```
2 * 4 (Object header) + 4 (length-field) + sizeof(primitiveType) * length
				-> выровнять результат, до кратного 8.
```
2) Массив объектов:
```
2 * 4 (Object header) + 4 (length-field) + 4(размер ссылки на объект) * length
				-> выровнять результат, до кратного 8.
```
3) Подсчет размера хранимого в массиве объекта:
```
java.lang.Object: 2 * 4 (Object header)

other objects:
	sizeofSuperClass
	+ 8 * longAndDoubleFields
	+ 4 * intAndFloatAndObjectFields
	+ 2 * shortAndCharFields
	+ 1 * byteAndBooleanFields
	-> выровнять результат, до кратного 8
```

##### 64 bit системы
1) Массив примитивных типов (`boolean`, `byte`, `char`, `short`, `int`):
```
2 * 8 (Object header)
+ 4 (length-field)
+ sizeof(primitiveType) * length
-> выровнять результат, до кратного 8.
```
2) Массив объектов:
```
2 * 8 (Object header)
+ 4 (length-field)
+ 4 (dead space due to alignment restrictions)
+ 8(размер ссылки на объект) * length
```
3) Подсчет размера хранимого в массиве объекта:
```
java.lang.Object: 2 * 8 (Object header)

other objects:
	sizeofSuperClass
	+ 8 * longAndDoubleAndObjectFields
	+ 4 * intAndFloatFields
	+ 2 * shortAndCharFields
	+ 1 * byteAndBooleanFields
	-> выровнять результат, до кратного 8
```

### Ссылочные типы данных
> В java размер любого объекта **КРАТЕН** 8 байтам

#### Материалы
[статья](https://habr.com/ru/articles/134102/)

#### Из чего же состоит объект?
JVM хранит для каждого объекта:
- Заголовок объекта;
- Память для примитивных типов;
- Память для ссылочных типов;
- Смещение/выравнивание - по сути, это несколько неиспользуемых байт, что размещаются после данных самого объекта. Это сделано для того, чтобы адрес в памяти всегда был кратным [[Dictionary#Машинное слово | машинному слову]], для ускорения чтения из памяти + уменьшения количества бит для указателя на объект + предположительно для уменьшения фрагментации памяти. При этом в java, вне зависимости от разрядности системы, размер любого объекта кратен 64 битам (8 байтам).

##### Структура заголовка объекта
- Маркировочное слово (mark word)
- Hash Code — каждый объект имеет хеш код.
  >По умолчанию результат вызова метода Object.hashCode() вернет адрес объекта в памяти, тем не менее некоторые сборщики мусора могут перемещать объекты в памяти, но хеш код всегда остается одним и тем же.
- Garbage Collection Information — каждый java объект содержит информацию нужную для системы управления памятью.
  > Зачастую это один или два бита-флага, но также это может быть, например, некая комбинация битов для хранения количества ссылок на объект.
- Type Information Block Pointer — содержит информацию о типе объекта. 
  > Этот блок включает информацию о таблице виртуальных методов, указатель на объект, который представляет тип и указатели на некоторые дополнительные структуры, для более эффективных вызовов интерфейсов и динамической проверки типов.
- Lock — каждый объект содержит информацию о состоянии блокировки.
  > Это может быть указатель на объект блокировки или прямое представление блокировки.
- Array Length — если объект — массив, то заголовок расширяется 4 байтами для хранения длины массива.

##### Спецификация java
- Примитивные типы в java имеют предопределенный размер, этого требует спецификация для переносимости кода.
<br>
- А что же говорит спецификация для объектов?
Ничего, кроме того, что у каждого объекта есть заголовок. Иными словами, размеры экземпляров Ваших классов могут отличатся от одной JVM к другой.

###### Размер ссылки
> Размер ссылки в JVM зависит от ее разрядности, для оптимизации.
> Поэтому в 32-х разрядных JVM размер ссылки обычно 4 байта, а в 64-х разрядных — 8 байт.

- На практике 64-разрядной версии требуется на 30-50% больше памяти из-за того, что ссылки в два раза больше.

##### Examples
> 32-х разрядная HotSpot JVM

###### Integer
> Нас интересуют все поля, не помеченные `static`.

```java
private final int value;
```

```
Заголовок: 8(4*2) байт
Поле int: 4 байта
Выравнивание для кратности 8 : 4 байта
Итого: 16 байт
```

###### String
```java
private final char value[];
private final int offset;
private final int count;
private int hash;
```

```
Заголовок: 8 байт
Поля int: 4 байта * 3 == 12 байт
Ссылочная переменная на объект массива: 4 байта
Итого: 24 байта
```

Так как строка содержит ссылку на массив символов, то, по сути, мы имеем дело с двумя разными объектами — объектом класса String и самим массивом, который хранит строку. Это, как бы, верно с точки зрения ООП, но если посмотреть на это со стороны памяти, то к полученному размеру нужно добавить и размер выделенного для символов массива.

```
new String()
Заголовок: 8 байт
Поля int: 4 байта * 3 == 12 байт
Ссылочная переменная на объект массива: 4 байта
Итого: 24 байта

new char[1]
Заголовок: 8 байт + 4 байта на длину массива == 12 байт
Примитивы char: 2 байта * 1 == 2 байта
Выравнивание для кратности 8 : 2 байта
Итого: 16 байта

Итого, new String("a") == 40 байт
```

> Важно отметить, что `new String(«a»)` и `new String(«aa»)` будут занимать одинаковое количество памяти(из-за пустых 2-х байт после выравнивания).
> Типичный пример использования этого факта в свою пользу — поле hash в классе String. Если бы его не было, то объект строки так или иначе занимал бы 24 байта, за счет выравнивания. А так получается что для этих 4-х байтов нашлось очень достойное применение.

