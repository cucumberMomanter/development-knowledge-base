`JVM` запускает `Java`-программы внутри себя. Как и любая виртуальная машина, она имеет собственную систему организации памяти.

Модель памяти в Java, используемая внутри `JVM`, делит память на `стеки потоков` (thread stacks) и `кучу` (heap).
![[Pasted image 20241011121553.png | 300]]

`Stack` - это история работы потока, история вызова методов.
`Heap` - это хранилище объектов.

- Куча имеет гораздо больший размер по сравнению со стеком;
- Стек хранит ссылки на объекты из кучи;
- Стеков может быть много (по одному на каждый поток), но куча для всех стеков общая.

### Материалы
[Java-модель памяти (часть 1)](https://habr.com/ru/articles/510454/)
[Java-модель памяти (часть 2)](https://habr.com/ru/articles/510618/)
[Javarush](https://javarush.com/quests/lectures/questservlets.level18.lecture00)

### Stack
> Стек содержит информацию о том, какие методы вызвал поток.
> 
> Стек отвечает за **хранение ссылок** на объекты кучи и за **хранение примитивных типов** (которые содержат само значение, а не ссылку на объект из кучи).

- **Каждый поток**, работающий в виртуальной машине Java, **имеет свой** собственный **стек**.
- Стек потока содержит все локальные переменные для каждого выполняемого метода.
- Поток может получить доступ только к своему стеку.
- Каждый поток имеет свою версию каждой локальной переменной, даже если они выполняют один и тот же код.
- Один поток может передать копию примитивной переменной другому потоку, но **не может совместно использовать примитивную локальную переменную**. (но возможно использование одних и тех же объектов).

Переменные в стеке имеют определенную видимость, также называемую **областью видимости**. Используются только объекты из <font style="color:red">активной области</font>.

---
Например:
- выполняем тело метода;
- у нас есть только локальные переменные (нет никаких глобальных переменных области видимости)

Если компилятор выполняет тело метода, он может получить доступ только к объектам из стека, которые находятся **внутри тела метода**.
Он не может получить доступ к другим локальным переменным, так как они **НЕ** входят в область видимости.
Когда метод завершается и возвращается, верхняя часть стека выталкивается, и активная область видимости изменяется.

---


### Heap (Куча)
> Куча содержит все объекты, созданные в вашем приложении, независимо от того, какой поток создал объект.

- К объектам в куче могут обращаться все потоки, имеющие ссылку на объект.
- Когда поток имеет доступ к объекту, он также может получить доступ к переменным-членам этого объекта.

 <font style=color:red>ВАЖНЫЙ МОМЕНТ</font>: Если два потока вызывают `метод` у одного и того же объекта одновременно, они оба будут иметь доступ к переменным-членам объекта, но **каждый поток** будет иметь свою **собственную копию локальных переменных** (переменных из метода). 

### Хранение переменных
- Локальная переменная может быть примитивного типа, в этом случае она полностью хранится в стеке потока.
- Локальная переменная также может быть ссылкой на объект. В этом случае ссылка (локальная переменная) хранится в стеке потоков, но сам объект хранится в куче.
- Объект может содержать методы, и эти методы могут содержать локальные переменные. Эти локальные переменные также хранятся в стеке потоков, даже если объект, которому принадлежит метод, хранится в куче.
- Переменные-члены объекта хранятся в куче вместе с самим объектом. Это верно как в случае, когда переменная-член имеет примитивный тип, так и в том случае, если она является ссылкой на объект.
- Статические переменные класса также хранятся в куче вместе с определением класса.

### Пример 

```java
public class MyRunnable implements Runnable {  
  
    public void run() {  
        methodOne();  
    }  
  
    public void methodOne() {  
        int localVariable1 = 45;  
        Car localVariable2 = Car.carInstance;  
        //... do more with local variables.  
  
        methodTwo();  
    }  
  
    public void methodTwo() {  
        Integer localVariable1 = new Integer(99);  
        //... do more with local variable.  
    }  
}  
  
class Car {  
    /**  
     * статическая переменная, указывающая на экземпляр Car
     */
     public static final Car carInstance = new Car();  
      
    /**  
     * переменные-члены, указывающие на два объекта в куче
     */
     public Integer object2 = new Integer(22);  
     public Integer object4 = new Integer(44);  
  
     public long member1 = 12345;  
     public long member2 = 67890;  
}
```
- `run()` вызывает `methodOne()`, а `methodOne()` вызывает `methodTwo()`.
- `methodOne()` объявляет:
  - примитивную локальную переменную (`localVariable1`);
  - ссылочную локальную переменную (`localVariable2`) - **статическую**.
- `methodTwo()` - объявляет:
  - ссылочную локальную переменную (`localVariable1`).

Диаграмма иллюстрирующая приведенный пример в памяти:
![[Pasted image 20241011130724.png]]

> Каждый поток, выполняющий `methodOne()`, создаст свою собственную копию `localVariable1` и `localVariable2` в своих соответствующих стеках.

- переменные `localVariable1` будут полностью отделены друг от друга, находясь в стеке каждого потока. Один поток не может видеть, какие изменения вносит другой поток в свою копию `localVariable1`;
-  каждый поток также создает свою собственную копию `localVariable2` (собственная копия ссылки).
  Однако две разные копии `localVariable2` будут указывать на один и тот же объект в куче. Т.к. `localVariable2` статическая переменная (принадлежит классу) - существует только одна копия статической переменной, и эта копия хранится в куче. (<font style=color:red>Object3</font> на диаграмме).

---
Статическая переменная `localVariable2` (объект класса `Car`) содержит в себе:
- две ссылочные переменные (`object2` и `object4`);
- две примитивные переменные (`member1` и `member2`).

Т.к. эти переменные, как ссылочные, так и **примитивные** являются **частью объекта**, они **хранятся в куче** вместе с объектом.
`В стеке потоков хранятся только локальные переменные.`

---

> Каждый поток, выполняющий `methodTwo()` создаст свою собственную копию `localVariable1`.

- метод создает новый объект `Integer` при каждом выполнении, два потока, выполняющие этот метод, будут содержать разные экземпляры `Integer`. (<font style=color:red>Object1</font>  и <font style=color:red>Object5</font> на диаграмме)

### Аппаратная архитектура памяти
Современная аппаратная архитектура памяти несколько отличается от внутренней Java-модели памяти. Важно понимать аппаратную архитектуру, чтобы понять, как с ней работает Java-модель.

Упрощенная схема аппаратной архитектуры современного компьютера:
![[Pasted image 20241012092035.png]]

Современный компьютер часто имеет 2 или более процессоров. Некоторые из этих процессоров также могут иметь несколько ядер. Каждое ядро процессора способно выполнять один поток в любой момент времени. Это значит, что любое Java-приложение является априори многопоточным и внутри вашей программы может быть запущено по одному потоку на ядро процессора одновременно.

Ядро процессора содержит `набор регистров`, которые находятся в его памяти (внутри ядра). Операции над данными `регистра` выполняются намного быстрее чем над данными в основной памятью (ОЗУ). И даже быстрее чем нал данными в `CPU cache`.

Каждый процессор так же может иметь свой слой `кэш-памяти`. Более того, у процессоров имеет место быть многоуровневый кэш.

Скорость выполнения операций в разной памяти будет в следующем порядке (от большей к меньшей) : `Register` -> `CPU cache` -> `ОЗУ`.

Когда процессору нужен доступ к основной памяти:
- он считывает ее часть в свою `кэш-память`;
- он также может считывать часть данных из `кэша` в свои внутренние `регистры`;
- и затем выполнять операции над этими данными.

Когда `CPU` необходимо будет записать результат опять в `ОЗУ`:
- он сбросит данные из своего внутреннего `регистра` в `кэш-память`;
- **и в какой-то момент**, из `кэша` в `ОЗУ`.

---
Данные, хранящиеся в `кэш-памяти`, в обычном случае сбрасываются обратно в основную память, когда процессору необходимо сохранить в кэш-памяти что-то еще.

Кэш имеет возможность очищать свою память и записывать данные одновременно.
Т.к. у процессора **нет необходимости** читать или записывать **полный кэш** каждый раз во время обновления.
Обычно кэш обновляется небольшими блоками памяти, они называются <font style="color:red">строка кэша</font>.
Одна или несколько <font style="color:red">строк кэша</font> могут быть считаны в `кэш-память`, и одна или более строк кэша могут быть сброшены назад в `ОЗУ`.

---

### Совмещение Java-модели памяти и аппаратной архитектуры памяти
`Java-модель` памяти и `аппаратная архитектура` памяти различны.
Аппаратная архитектура не различает стеки потоков и кучу.
На оборудовании `стек потоков` и `HEAP` (куча) находятся в основной памяти.

![[Pasted image 20241012102624.png]]

Когда объекты и переменные могут храниться в различных областях памяти компьютера, могут возникнуть определенные проблемы.

Вот две основные:
- Видимость изменений, которые произвел поток над общими переменными.
- Состояние гонки при чтении, проверке и записи общих переменных.

#### Видимость общих объектов (`volatile`)
> Если два или более потока делят между собой объект без надлежащего использования `volatile`-объявления или `синхронизации`, то изменения общего объекта, сделанные одним потоком, **могут быть невидимы для других потоков**.

![[Pasted image 20241012103931.png]]

- общий объект хранится в `ОЗУ`;
- `thread1`считывает общий объект в кэш ЦП и вносит изменения в объект;
- до того как `thread1` сбросил изменения в `ОЗУ` -> `thread2` так же вычитал общий объект в кэш ЦП и внес в него изменения;
---
Пока кэш ЦП не был сброшен в основную память, измененная версия общего объекта не видна потокам, работающим на других ЦП.
Таким образом, каждый поток может получить свою собственную копию общего объекта, каждая копия будет находиться в отдельном кэше ЦП.

---
Для решения этой проблемы можно использовать ключевое слово `volatile` при объявлении переменной.
Оно гарантирует, что переменная будет хранится только в `ОЗУ`.

#### Состояние гонки (race condition)
> Если два или более потоков совместно используют один объект и более одного потока обновляют переменные в этом общем объекте, то может возникнуть состояние гонки.

![[Pasted image 20241012104225.png]]
- поток `A` считывает переменную count общего объекта в кэш своего процессора;
- поток `B` делает то же самое, но в кэш другого процессора;
- поток `A` прибавляет `1` к значению переменной `count`;
- поток `B` делает то же самое;

Переменная `count` была увеличена дважды — отдельно по `+1` в кэше каждого процессора.
Если бы эти приращения были выполнены последовательно, переменная `count`  в основной памяти имела бы значение: `исходное значение + 2`.
Но два приращения были выполнены одновременно **БЕЗ** надлежащей синхронизации. Независимо от того, какой из потоков (`A` или `B`), запишет свою обновленную версию `count` в `ОЗУ`, новое значение будет только на `1` больше исходного значения.

> Решения проблемы : использовать `синхронизированный блок Java`.

Синхронизированный блок гарантирует, что **ТОЛЬКО ОДИН поток** может войти в данный критический раздел кода в любой момент времени.

<font style="color:violet">
Синхронизированные блоки также гарантируют, что все переменные, к которым обращаются внутри синхронизированного блока, будут считаны из основной памяти, и когда поток выйдет из синхронизированного блока, все обновленные переменные будут снова сброшены в основную память, независимо от того, объявлена ли переменная как volatile или нет.
</font>

### Java Memory Model
