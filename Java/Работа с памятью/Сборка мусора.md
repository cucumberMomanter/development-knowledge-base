 > Сборка мусора — это процесс восстановления заполненной памяти среды выполнения путем уничтожения неиспользуемых объектов.

В таких языках, как C и C++, программист отвечает как за создание, так и за уничтожение объектов. В C++ для сборки мусора можно воспользоваться методом `delete()`, а в C — методом `free()`.

 Иногда программист может забыть уничтожить бесполезные объекты, и выделенная им память не освобождается. Расходуется все больше и больше системной памяти, и в конечном итоге она больше не выделяется. Такие приложения страдают от `утечек памяти`.

> Сборка мусора в Java — это процесс, с помощью которого программы Java автоматически управляют памятью.

Когда Java-программы выполняются на JVM, объекты создаются в куче, которая представляет собой часть памяти, выделенную для них.

Пока Java-приложение работает, в нем создаются и запускаются новые объекты. В конце концов некоторые объекты перестают быть нужны. Можно сказать, что в любой момент времени память кучи состоит из двух типов объектов.

- Живые — эти объекты используются, на них ссылаются откуда-то еще.
- Мертвые — эти объекты больше нигде не используются, ссылок на них нет.

Сборщик мусора находит эти неиспользуемые объекты и удаляет их, чтобы освободить память.

Каждая JVM может реализовать собственную версию сборки мусора. Однако сборщик должен соответствовать стандартной спецификации JVM для работы с объектами, присутствующими в памяти кучи, для маркировки или идентификации недостижимых объектов и их уничтожения через уплотнение.

### Материалы
[Сборка мусора в Java](https://vc.ru/dev/397062-sborka-musora-v-java-chto-eto-takoe-i-kak-rabotaet-v-jvm)

### Достижимость объектов
> Чтобы признать объект живым — наличия ссылок недостаточно.
> Т.к. одни мертвые объекты могут ссылаться на другие мертвые объекты.
> Именно поэтому нужно, чтобы среди всех ссылок на объект, была хотя бы одна от “живого” объекта.

![[Pasted image 20241011095134.png]]

Сборщики мусора работают с концепцией <font style="color:red">GC Roots</font> (**корней сбора мусора**) для того, чтоб различать живые и мертвые объекты.
Есть 100% живые объекты и от них идут ссылки, которые оживляют другие объекты и так далее.

Примеры таких корней:
- Классы, которые загружаются системным загрузчиком классов (не пользовательские загрузчики классов).
- Живые потоки.
- Локальные переменные и параметры выполняемых в данный момент методов.
- Объекты, которые применяются в качестве монитора для синхронизации.
- Объекты, удерживаемые из сборки мусора JVM для своих целей.

Сборщик мусора просматривает весь граф объектов в памяти, начиная с этих корней и следуя ссылкам на другие объекты.

### Этапы сборки мусора
#### 1. Помечаем объекты как живые
На этом этапе GC (сборщик мусора) идентифицирует все живые объекты в памяти путем обхода графа объектов.

Когда GC посещает объект, то помечает его как доступный и, следовательно, живой. Все объекты, **недоступные из корней GC**, рассматриваются как кандидаты на сбор мусора.

![[Pasted image 20241013121706.png]]

#### 2. Зачистка мертвых объектов
После фазы разметки пространство памяти занято либо живыми (посещенными), либо мертвыми (не посещенными) объектами. Фаза зачистки освобождает фрагменты памяти, которые содержат эти мертвые объекты.

![[Pasted image 20241013121715.png]]

#### 3. Компактное расположение оставшихся объектов в памяти
Мертвые объекты, которые были удалены во время предыдущей фазы, не обязательно находились рядом друг с другом. Поэтому вы рискуете получить фрагментированное пространство памяти.

Память можно уплотнить **в момент**, когда сборщик мусора удалит мертвые объекты. Оставшиеся будут располагаться в непрерывном блоке в начале кучи.

Процесс уплотнения облегчает последовательное выделение памяти для новых объектов.

![[Pasted image 20241013121723.png]]

### Сборка мусора по поколениям
Сборщики мусора в Java реализуют стратегию сбора мусора поколений, которая классифицирует объекты по возрасту.

Необходимость отмечать и уплотнять все объекты в JVM неэффективна. По мере выделения все большего количества объектов их список растет, что приводит к увеличению времени сбора мусора. Эмпирический анализ приложений показал, что большинство объектов в Java недолговечны. (`Какого приложения?`, `Только одного приложения?`).
<font style="color:violet">Важно понимать на основе какого именно приложения проводился анализ.
Ведь приложения могут быть написаны по разному, даже в части использования памяти.</font>
<font style="color:red">Но думаю в большинстве случаев данный вывод - это true.
</font>

Большинство объектов живут очень мало. **Вот почему Java классифицирует объекты** по поколениям и выполняет сборку мусора в соответствии с ними.

Область памяти кучи в JVM разделена на три секции:
![[Pasted image 20241013142036.png]]

#### 1. Молодое поколение
Вновь созданные объекты начинаются в молодом поколении. Молодое поколение далее подразделяется на две категории:
- **Пространство Эдема** (`Eden Space`) — все новые объекты начинают здесь, и им выделяется начальная память.
- **Пространства выживших** (`From Space` и `To Space`) — объекты перемещаются сюда из Эдема после того, как пережили один цикл сборки мусора.

Процесс, когда объекты собираются в мусор из молодого поколения, называется **малым событием сборки мусора**.

Когда пространство Эдема заполнено объектами, выполняется малая сборка мусора.
Все мертвые объекты удаляются, а все живые — перемещаются в одно из пространств выживших (`в то, которое пустое`).
Малая GC также проверяет объекты в пространстве выживших (`то, которое было заполненно`) и перемещает их в другое (`пустое`) пространство выживших.

Возьмем в качестве примера следующую последовательность.
1. В `Эдеме` есть объекты обоих типов (живые и мертвые).
2. Происходит малая GC — все мертвые объекты удаляются из Эдема. Все живые объекты перемещаются в `пространство-1` (`FromSpace`).
   `Эдем` и `пространство-2` теперь **пусты**.
3. Новые объекты создаются и добавляются в `Эдем`.
   Некоторые объекты в `Эдеме` и п`ространстве-1` становятся мертвыми.
4. Происходит малая GC — все мертвые объекты удаляются из `Эдема` и `пространства-1`.
   Все живые объекты перемещаются в `пространство-2` (`ToSpace`).
   `Эдем` и `пространство-1` снова пусты.

---
Таким образом, в любое время **одно из пространств для выживших** <font style="color:red">всегда пусто</font>.
Когда выжившие объекты достигают определенного порога **перемещения по пространствам выживших**, они переходят в старшее поколение.

---

Для установки размера молодого поколения можно воспользоваться флагом `-Xmn`

#### 2. Старшее поколение
Объекты-долгожители в конечном итоге переходят из молодого поколения в старшее. Оно также известно как штатное поколение и содержит объекты, которые долгое время оставались в пространствах выживших.

Пороговое значение срока службы объекта (`кол-во циклов сборки мусора`) определяет, сколько циклов сборки мусора он может пережить, прежде чем будет перемещен в старшее поколение.

Процесс, когда объекты отправляются в мусор из старшего поколения, называется **основным событием сборки мусора**.

Поскольку Java задействует сборку мусора по поколениям, то чем больше событий сборки мусора переживает объект, тем дальше он продвигается в куче. Он начинает в молодом поколении и в конечном итоге заканчивает в штатном поколении, если проживет достаточно долго.

Когда объект создается, он сначала помещается в пространство `Эдема` молодого поколения. Как только происходит малая сборка мусора, живые объекты из `Эдема` перемещаются в пространство `FromSpace`. Когда происходит следующая малая сборка мусора, живые объекты как из `Эдема`, так и из `FromSpace` перемещаются в пространство `ToSpace`. 

Этот цикл продолжается определенное количество раз. Если объект все еще `в строю` после этого момента, следующий цикл сборки мусора переместит его в пространство старшего поколения.

#### 3. Постоянное поколение и мета-пространство
##### Постоянное поколение (`до java 8`)
> **Permanent Generation**

Метаданные, такие как классы и методы, хранятся в постоянном поколении. JVM заполняет его во время выполнения на основе классов, используемых приложением. Классы, которые больше не используются, могут переходить из постоянного поколения в мусор.

Для установки начального и максимального размера постоянного поколения можно воспользоваться флагами **-XX:PermGen** и **-XX:MaxPermGen**.

##### Мета-пространство (`с java 8`)
> **MetaSpace**

Начиная с Java 8, на смену пространству постоянного поколения (`PermGen`) приходит пространство памяти `MetaSpace`.
Реализация отличается от `PermGen` — это пространство кучи теперь изменяется автоматически.

Это позволяет избежать проблемы нехватки памяти у приложений, которая возникает из-за ограниченного размера пространства PermGen в куче. Память мета-пространства может быть собрана как мусор, и классы, которые больше не используются, будут автоматически очищены, когда мета-пространство достигнет максимального размера.

### Типы сборщиков мусора в JVM
Сборка мусора повышает эффективность работы с памятью в Java, так как объекты, не имеющие ссылок удаляются из кучи и освобождается место для новосозданных объектов.

**Stop The World** -  это полная остановка потоков программы для безопасной сборки мусора и других системных операций.

#### Serial GC
Это самая простая реализация GC.
-  предназначена для небольших приложений, работающих в однопоточных средах;
- все события сборки мусора выполняются последовательно в одном потоке;
- уплотнение выполняется после каждой сборки мусора.

![[Pasted image 20241013205053.png]]

Запуск сборщика приводит к событию **Stop The World** (остановки мира), когда все приложение приостанавливает работу.

Аргумент `JVM` для использования последовательного сборщика мусора:
```shell
XX:+UseSerialGC
```

#### Parallel GC
Параллельный сборщик мусора предназначен для приложений со средними и большими наборами данных, которые выполняются на многопроцессорном или многопоточном оборудовании.

- несколько потоков предназначаются для малой сборки мусора в молодом поколении;
- единственный поток занят основной сборкой мусора в старшем поколении;
- т.е. ускоряет сборку мусора только в `Young generation`.

![[Pasted image 20241013205743.png]]

Запуск параллельного GC также вызывает **Stop The World**, и приложение зависает.

Аргумент `JVM` для использования параллельного сборщика мусора:
```shell
-XX:+UseParallelGC
```

##### Parallel Compacting GC
> Это то же самое, что и `Parallel GC`, за исключением того, что в нем применяются несколько потоков как для молодого поколения, так и для старшего поколения.

Аргумент `JVM` для использования старого параллельного сборщика мусора:
```shell
-XX:+UseParallelOldGC
```

#### CMS (Параллельная пометка и зачистка) GC
> Также известен нам как **параллельный сборщик низких пауз**.

- `CMS` работает одновременно с процессами приложений, чтобы свести к минимуму `stop-the-world`;
- В `CMS GC` **НЕ** выполняется уплотнение.

![[Pasted image 20241013213416.png]]

Работа `CMS` начинается с очень короткой `stop-the-world` паузы, в течении которой исполняется `initial mark`.

1. **initial mark** - сборщик мусора находит так называемые корневые (`root`) ссылки на объекты, созданные приложением.

Далее, одновременно с работой приложения выполняется `concurrent mark`.

2. **concurrent mark** - отмечает все объекты, достижимые из корневых объектов, то есть все «живые» объекты, которые не должны удаляться сборщиком мусора.

Так как во время `concurrent mark` потоки приложения продолжали работать, и в это время они могли создавать новые объекты и модифицировать ссылки, то к концу `concurrent mark` нет гарантии, что все живые объекты были отмечены.
Чтобы решить эту проблему CMS ещё раз делает `stop-the-world` и выполняет `remark`.

3. **remark** - проверяю все объекты, которые были изменены пользовательскими потоками во время выполнения `concurrent mark`. Т.е. эти объекты еще отдельно помечаются при выполнении `concurrent mark`.

4. **concurrent sweep** - вместе с работой приложения удаляется весь найденный мусор.

<br>
Аргумент `JVM` для использования параллельного сборщика мусора с разверткой меток:
```shell
-XX:+UseConcMarkSweepGC
```

#### G1 (Мусор — первым) GC
Хотя G1 также действует по принципу поколений, в нем нет отдельных пространств для молодого и старшего поколений.

Куча - это одна область памяти, разделенная на множество областей фиксированного размера.

Характеристика областей:
- каждая из областей представляет собой непрерывный диапазон виртуальной памяти);
- размер региона выбирается JVM при запуске. Обычно JVM использует около `2000` регионов размером от `1` до `32` Мб.
- 

![[Pasted image 20241014083306.png | 500]]

Помимо областей Эдема, Выживших и Старой памяти, в G1GC присутствуют еще два типа:
- `Humongous` (Огромная) - область предназначена для хранения объектов, которые  `>= 50%` размера стандартного региона (того, который `1 - 32` Мб).
- `Available` (Доступная) — неиспользуемое или не выделенное пространство.

Аргумент `JVM` для использования сборщика мусора `G1`:
```shell
-XX:+UseG1GC
```

###
bean factory
bean processor

prototype не хранится в контексте
- и по этому не вызывается метод destroy()
- spring создает prototype bean по запросу, отдает его и забывает про него.


контракт equals и hashcode
контракт переопределения методов

конвариантность контр вариантность и еще че то

спосоюы создания бинов

auth 2.0
elastic search - не реляционная
 +/- блокировки
методы создания бина:
- аннотации
- java code
- xml
- создать объект и напрямую затолкать в контекст

transient


про stream в параметр метода (они одноразовые)
- когда приходит стрим в параметр метода мы не знаем живой он или нет, а возможности проверить нет.

кубер основные компоненты
кафка горантии получения и доставки
volatile нужен, чтобы изменение переменной были видны другим потокам. то есть обеспечивает видимость.

 по hibernate для чего, что дает нам маппинг (В JDBC его нет напрмер).

дистанционное банковское обслуживание
open session in view
 
_________________________________________________
category
------------------------
| id | name            |
------------------------
|1   |Сладости         |
|2   |Мясо             |
|3   |Молочные продукты|
------------------------

product
-------------------------------------------
| id | category_id | price | name         |
-------------------------------------------
|1   |1            |50     |Печенье       |
|2   |1            |70     |Мармелад      |
|3   |1            |150    |Конфеты       |
|4   |2            |150    |Куриная грудка|
|5   |2            |400    |Свинина       |
|6   |3            |100    |Молоко        |
|7   |3            |120    |Кефир         |
-------------------------------------------

Найти количество товаров, в той же категории, что и 'Конфеты', которые дешевле 100 рублей.

select count(*)
from product
where price <= 100 && category_id in(select category_id from prodoct where name = 'Конфеты')


// Дан массив чисел в котором все числа кроме одного имеют пару(встречаются дважды).
// Найти число, которое встречается только один раз.
// Например: массив [1, 0, -2, 3, 9, 9, 1, -2, 0], пары нет у 3.

int find(int[] arr) {
	// проверка arr на null и пустоту
    LinkedHashMap<Integer, Object> map = new LinkedHashMap(16, 0.75f, true);
    
    for (int i = 0; i < arr.length; i++) {
        map.merge(arr[i], 1, (v1, v2) -> v1++);
    }
    
    int result = map.firstEntry().getValue();
    
    if (result > 1) {
        throw new RuntimeException("Not found");
    }
    // проверка что таких уникальных пар > 1
    
    return map.firstEntry().getKey();
}

int find(int[] arr) {
    Map<Integer, Object> map = new HashMap();
    
    for (int i = 0; i < arr.length; i++) {
        map.put(arr[i], stub);
    }
    
    return map.firstEntry().getKey();
}


--------------------------------------------------------------------------------
-- Есть таблицы со структурой

Employee
id (PK) -- табельный номер сотрудника
name
salary
dept_id (FK)


-- Пример данных:

|--|----------|------|-------|
|id|name      |salary|dept_id|
|--|----------|------|-------|
|2 |Иванов    |120   |20     |
|3 |Петров    |100   |10     |
|5 |Ионов     |100   |10     |
|4 |Сидоров   |1000  |       |
|7 |Рабинович |90    |20     |
|8 |Забелин   |100   |20     |
|--|----------|------|-------|

Department
id (PK) -- НОМЕР
name


-- Пример данных:

|--|-------------------|
|id|name               |
|--|-------------------|
|10|продажи            |
|20|закупки            |
|30|аналитический отдел|
|--|-------------------|

-- Найдите самую большую зарплату в каждом отделе

select Department.name max(salary) as max_salary
from Employee right join Department on Employee.dept_id = Department.id
group by Department.id;